{"meta":{"title":"ThunderFireSwordBlog","subtitle":"","description":"","author":"ThunderFireSword","url":"https://thunderfiresword.github.io/project","root":"/"},"pages":[{"title":"categories","date":"2023-06-29T07:41:40.000Z","updated":"2023-06-29T07:41:55.882Z","comments":false,"path":"categories/index.html","permalink":"https://thunderfiresword.github.io/project/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-06-29T07:41:03.000Z","updated":"2023-06-29T07:41:28.954Z","comments":false,"path":"tags/index.html","permalink":"https://thunderfiresword.github.io/project/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"以太坊区块链私链搭建和使用web3.js与节点进行交互","slug":"blog001","date":"2023-06-29T01:53:43.000Z","updated":"2023-06-30T03:11:18.432Z","comments":true,"path":"2023/06/29/blog001/","link":"","permalink":"https://thunderfiresword.github.io/project/2023/06/29/blog001/","excerpt":"","text":"简介： 包括以太坊私链搭建、geth控制台使用、&#119;&#x65;&#98;&#x33;&#46;&#106;&#115;&#x40;&#49;&#x2e;&#x32;&#x2e;&#x36;和&#119;&#x65;&#x62;&#51;&#46;&#x6a;&#115;&#x40;&#48;&#x2e;&#50;&#46;&#x30;部署合约与合约交互 版本： 以太坊：go-ethereum-1.9.25 操作系统：CentOS7 以太坊私链搭建前置：安装go环境、Geth、下载go-ethereum 123git clone https:&#x2F;&#x2F;github.com&#x2F;ethereum&#x2F;go-ethereumcd go-ethereummake geth 配置创世区块需要创建一个目录放置创世区块的文件genesis.json和节点文件夹 例如我把blockchain-setting作为节点的目录 123blockchain-setting├── node1 &#x2F;&#x2F;节点文件夹└── genesis.json &#x2F;&#x2F;创世区块配置 genesis.json内容为 1234567891011121314151617181920212223242526272829&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 11, &quot;homesteadBlock&quot;: 0, &quot;eip150Block&quot;: 0, &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;eip155Block&quot;: 0, &quot;eip158Block&quot;: 0, &quot;byzantiumBlock&quot;: 0, &quot;constantinopleBlock&quot;: 0, &quot;petersburgBlock&quot;: 0, &quot;ethash&quot;: &#123;&#125; &#125;, &quot;nonce&quot;: &quot;0x0&quot;, &quot;timestamp&quot;: &quot;0x5d5cdc87&quot;, &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;gasLimit&quot;: &quot;0x47b760&quot;, &quot;difficulty&quot;: &quot;0x80000&quot;, &quot;mixHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;alloc&quot;: &#123; &quot;0000000000000000000000000000000000000000&quot;: &#123; &quot;balance&quot;: &quot;0x1&quot; &#125; &#125;, &quot;number&quot;: &quot;0x0&quot;, &quot;gasUsed&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&#125; 需要按照最新的配置设置genesis.json，旧的配置中可能缺少配置项，在后续的调用合约时可能会引起报错 1invalid opcode: SHR 可能是缺少以下配置 12&quot;byzantiumBlock&quot;: 0,&quot;constantinopleBlock&quot;: 0 运行节点 初始化区块链12cd blockchain-setting &#x2F;&#x2F;打开上述目录geth --datadir node1 init genesis.json &#x2F;&#x2F;初始化区块链 node1节点文件 初始化成功之后node1目录下会出现keystore、geth和history 其中keystore目录下存放用户数据，geth&#x2F;chaindata存放区块数据 运行在节点目录下运行节点 1geth --datadir node1 --networkid 11 --http --http.port 8545 --port 30303 -http.api eth,web3,personal,net --http.addr 0.0.0.0 --allow-insecure-unlock --nodiscover console 2&gt;&gt;geth.log 参数 --datadir node1 --networkid 11 [相关链接]: https://zhuanlan.zhihu.com/p/583143944 “以太坊 ChainId 与 NetworkId” --http --http.addr 0.0.0.0 --http.port 8545 --http.api eth,web3,personal,net --allow-insecure-unlock --nodiscover console 2&gt;&gt;geth.log [更多geth命令参数]: https://www.cnblogs.com/kaifayuan/p/14970409.html “geth命令参数详解 1.10.4” 启动成功之后进入geth控制台 可以再打开一个窗口在区块链目录下用以下命令查看日志 1tail -f geth.log geth控制台基本操作 查看已有账户1eth.accounts 新建账户1personal.newAccount(&quot;111&quot;) &#x2F;&#x2F;参数为密码 查看余额1eth.getBalance(eth.accounts[0]) &#x2F;&#x2F;参数为账户地址，这里查询第一个被创建的账户 image-20230626160150807 开始和停止挖矿12miner.start() &#x2F;&#x2F;开始挖矿，没有设置挖矿地址默认为第一个创建的账户miner.stop() &#x2F;&#x2F;停止挖矿 开始挖矿之后日志输出 设置挖矿地址1miner.setEtherbase(eth.accounts[1]) &#x2F;&#x2F;参数为账户地址，这里设置第二个创建的账户挖矿 设置该账户为挖矿地址之后进行挖矿，一段时间之后余额增加 当前区块数1eth.blockNumber 交易池状态1txpool.status 解锁账户1personal.unlockAccount(eth.accounts[0]) 之后输入密码即可解锁 发起转账1eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[2],value:100000&#125;) 交易之前需要解锁账户 发起转账交易之后日志中会出现提交交易的提示，因为没有在挖矿，交易未被处理，在交易池中处于挂起状态 开始挖矿，一段时间后交易处理完成，可以看到转账成功 根据交易哈希查看交易1eth.getTransaction(&quot;0x14b6dfa57dd466ea8a2a4e9a7815c5b8afd4230361f7fb5e05483041c45a6edf&quot;) 在发送交易时会返回交易哈希值，或者在日志中提交交易一栏的fullhash字段可以找到该交易的交易哈希 退出控制台并停止节点运行1exit 日志中：INFO [06-26|16:35:29.626] Blockchain stopped 在geth控制台上部署智能合约 示例智能合约：实现了一个简单的将作品信息上传和查询的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity &gt;&#x3D;0.8.0;contract SimpCopyright&#123; &#x2F;** * @dev 事件日志，在版权转移时触发记录 *&#x2F; event Transfer(address indexed from, address indexed to, string indexed workId); &#x2F;** * work结构体： * owner 上链者账户 * ownerWebId 上链者在网站的账号 * workUri ipfs上地址 * workOwnername 上链者真实姓名 * workOwnerid 上链者证件号码 *&#x2F; struct Work&#123; address owner; string ownerWebId; string workUri; string workOwnername; string workOwnerid; &#125; &#x2F;&#x2F;该版权合约的创始者 address private _owner; &#x2F;&#x2F; 版权token名称 string private _name; &#x2F;&#x2F; 版权token标志 string private _symbol; &#x2F;&#x2F; 版权作品id到版权拥有者地址的映射，用于存储某个id作品的拥有者,版权作品id用版权文件hash作为唯一标识 mapping(string &#x3D;&gt; address) private _owners; &#x2F;&#x2F; 版权作品id到版权信息的映射，用于存储某个作品的详细信息，是一个结构体 mapping(string &#x3D;&gt; Work) private _works; &#x2F;&#x2F;构造方法 constructor(string memory name_, string memory symbol_)&#123; _name &#x3D; name_; _symbol &#x3D; symbol_; _owner &#x3D; msg.sender; &#125; function getName() public view returns (string memory) &#123; return _name; &#125; function getSymbol() public view returns (string memory) &#123; return _symbol; &#125; function getOwner() public view returns (address ) &#123; return _owner; &#125; &#x2F;** * @dev 查询某个作品id的区块链账户 *&#x2F; function FindOwnerId(string memory workId) public view returns (address) &#123; address owner &#x3D; _owners[workId]; return owner; &#125; &#x2F;** * @dev 获取作品的URI *&#x2F; function FindUri(string memory workId) public view returns (string memory) &#123; string memory _workURI &#x3D; _works[workId].workUri; return _workURI; &#125; &#x2F;** * @dev 获取作品的著作权人名字 *&#x2F; function FindWorkOwnername(string memory workId) public view returns (string memory) &#123; string memory _workOwnername &#x3D; _works[workId].workOwnername; return _workOwnername; &#125; &#x2F;** * @dev 获取作品的著作权人证件号码 *&#x2F; function FindWorkOwnerid(string memory workId) public view returns (string memory) &#123; string memory _workOwnerid &#x3D; _works[workId].workOwnerid; return _workOwnerid; &#125; &#x2F;** * @dev 添加作品 *&#x2F; function addWorks(address to, string memory ownerWebId, string memory workId, string memory uri ,string memory ownername ,string memory ownerid) public returns(bool) &#123; _addWorks(to, ownerWebId, workId, uri, ownername, ownerid); return true; &#125; &#x2F;** * @dev 添加作品，上链 *&#x2F; function _addWorks(address to, string memory _ownerWebId, string memory workId, string memory _workURI, string memory ownername, string memory ownerid) public &#123; _owners[workId] &#x3D; to; _works[workId].ownerWebId&#x3D;_ownerWebId; _works[workId].workUri&#x3D; _workURI; _works[workId].workOwnername&#x3D;ownername; _works[workId].workOwnerid&#x3D;ownerid; emit Transfer(address(0), to, workId); &#125;&#125; 部署合约需要编译后的abi和Bytecode，在remix编译器中在CONTRACT栏中选择智能合约编译，编译完成后可以点击下方ABI和Bytecode按钮复制 打开geth控制台，进行合约部署 123456var abi&#x3D;&#x2F;*复制的abi粘贴到此处*&#x2F;var bytecode&#x3D;&#x2F;*复制的bytecode粘贴到此处,开头加上0x*&#x2F;var Contract&#x3D;eth.contract(abi) &#x2F;&#x2F;通过abi创建合约对象&#x2F;*部署合约之前要先解锁账户*&#x2F;personal.unlockAccount(eth.accounts[0])contractInstance &#x3D; Contract.new(&quot;copyright&quot;,&quot;cpr&quot;,&#123;data:bytecode ,gas: 4700000, from: eth.accounts[0]&#125;) &#x2F;&#x2F;发送部署合约的交易，燃气费gas可以设大一点，用不完会返还 其中合约对象的new方法参数为（[para1],[para2],{[tansactionSetting]}） 前面为合约构造方法的参数（若构造方法无参数可以忽略），最后一个{}内是交易的设置（包含bytecode、gas等等） 燃气费的设置：可以使用eth.estimateGas({data:bytecode})来估算燃气费 例如示例合约中的构造方法有2个字符串参数，因此在{}前设置了2个字符串的参数 日志中提交合约部署： Submitted contract creation fullhash&#x3D;0xd77274b34452e177a203e05d0b5b50392134ce83dbf6e123c8e344e0f2f2154e contract&#x3D;0x254485cF390f8be507857c1C160b670E3715f847 同样需要挖矿将合约写入区块链 geth控制台调用智能合约12contractObj&#x3D;eth.contract(abi) &#x2F;&#x2F;根据abi构建合约对象contract&#x3D;contractObj.at(address) &#x2F;&#x2F;填入合约地址 此时可以使用contract调用方法 查询方法示例合约中的getName为查询方法，不改变区块链的状态，不用挖矿就可以执行，使用call()调用 1contract.[method].call([para1],[para2]) 示例 1contract.getName.call() &#x2F;&#x2F;使用call调用 发送交易改变区块链中状态的方法需要发送交易，需要挖矿才能执行，使用sendTransaction()调用，控制台中会返回交易哈希 1contract.[method].sendTransaction([para1],[para2],&#123;[tansactionSetting]&#125;) 示例 1contract2.addWorks.sendTransaction(eth.accounts[0],&#39;5&#39;,&#39;001&#39;,&#39;120.48.51.66&#39;,&#39;dl&#39;,&#39;46000***&#39;,&#123;from:eth.accounts[0]&#125;) 日志中会提示 Submitted transaction fullhash&#x3D;0x5b94548b402dd7813ec2218cef9170fb05f9d2d074bc6824ab4a859ee32734c7 recipient&#x3D;0x254485cF390f8be507857c1C160b670E3715f847 需要挖矿将交易处理 运行结果：使用合约中查询的方法进行验证 1contract2.FindWorkOwnername.call(&quot;001&quot;) 可以看到数据已经写入区块链中 使用web3js调用智能合约web3js安装v0.20 1npm install web3@^0.20.0 v1.2.6 1npm install web3@^1.2.6 链接到区块链v0.20 123var Web3=require(\"web3\")var web3 = new Web3()web3.setProvider(new Web3.providers.HttpProvider('[url]:8545'));//url处填入地址 v1.2.6 12var Web3=require(\"web3\")var web3 = new Web3(Web3.givenProvider || '[url]:8545'); 部署合约部署合约之前需要先使用web3.personal.unlockAccount([account],[password])解锁账户,希望使用js解锁账户需要在启动节点时加上参数--allow-insecure-unlock v0.20 与在geth上部署相同，先使用web3.eth.contract(abi)创建合约示例，再使用合约示例的new([constructorPara1],[constructorPara1],{[setting]},[callback])方法部署合约 [callback]为回调函数，为可选项 异步部署 12345678910111213141516171819//解锁账户web3.personal.unlockAccount(myAccount,password)//创建合约实例var myContract=web3.eth.contract(abi);//部署合约var myContractInstance=myContract.new(\"copyright\",\"cpr\",&#123; from:myAccount, //解锁的账户地址 data:bytecode, //合约的bytecode gas:4700000, //燃气费 &#125;,function (err,result) &#123; //会回调2次，第1次是在发起交易时生成交易哈希时回调，第2次是合约部署完成时回调，此时有合约的地址 if(!err) &#123; if(!myContractInstance.address) &#123; console.log(myContractInstance.transactionHash) &#125; else &#123; console.log(myContractInstance.address) &#125; &#125; &#125;) 同步部署，合约部署的地址可以通过查询发送部署时返回的交易哈希的to项找到，或者在日志中的Submitted contract creation记录中的contract项中找到 12345678910//解锁账户web3.personal.unlockAccount(myAccount,password)//创建合约实例var myContract=web3.eth.contract(abi);//部署合约，不加上callback即可var myContractInstance=myContract.new(\"copyright\",\"cpr\",&#123; from:myAccount, //解锁的账户地址 data:bytecode, //合约的bytecode gas:4700000, //燃气费 &#125;) v1.6.2 在remix编译器中的编译界面的编译详情中的web3deploy可以找到部署合约代码的模板 使用的方法： 构建合约对象：var simpcopyrightContract = new web3.eth.Contract(abi);参数为abi，与0.20不同之处在于Contract首字母大写 部署合约：var simpcopyright = simpcopyrightContract.deploy( {data: bytecode,arguments:[para1,para2]}).send({from:account,gas:gasNum},callback) 参数： data：bytecode argurements:[]：合约构造方法传参 示例：remix默认使用了第一个创建的账户进行部署 123456789101112131415161718var name_ = /* var of type string here */ ;var symbol_ = /* var of type string here */ ;var simpcopyrightContract = new web3.eth.Contract([abi]);var simpcopyright = simpcopyrightContract.deploy(&#123; data: [bytecode], arguments: [ name_, symbol_, ]&#125;).send(&#123; from: web3.eth.accounts[0], gas: '4700000' &#125;, function (e, contract)&#123; console.log(e, contract); if (typeof contract.address !== 'undefined') &#123; console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash); &#125; &#125;) 调用合约创建合约实体调用合约之前需要构造合约实体以调用方法 v0.20 12var myContract=web3.eth.contract(abi) //使用abi构建合约对象var myContractInstance=myContract.at(myContractAddress) 参数myContractAddress为部署好的合约地址 此时可以使用myContractInstance调用合约方法 查询方法与geth上调用智能合约使用同样的样例 v0.20 1myContractInstance.constantMethod.call(para1,para2) constantMethod为合约的方法名， para1、para2为该方法的参数，没有参数不用写 示例 123//将结果打印在控制台上console.log(simpCopyrightInstance.getName.call()); //无参数console.log(simpCopyrightInstance.FindWorkOwnername.call('001')); //有一个参数的方法 发送交易会改变区块链状态的方法需要通过发送交易的方式来调用 v0.20 1myContractInstance.changingStateMethod(para1,para2,callback) changingStateMethod为改变区块链状态的方法名 para1,para2为方法参数，没有参数不用写 callback为回调函数，可选项，支持异步执行 示例 12345678simpCopyrightInstance.addWorks(myAccount,'5','002','202.197.99.35/work002','dl2','46000***', function(err, result)&#123; if (!err)&#123; console.log(result)//把返回的交易哈希打印在控制台上 &#125;else &#123; console.log(err) &#125;&#125;) 用查询函数进行验证 1console.log(simpCopyrightInstance.FindWorkOwnername.call(\"002\")); //打印出'dl2'","categories":[],"tags":[]}],"categories":[],"tags":[]}